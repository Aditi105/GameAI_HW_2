#include <SFML/Graphics.hpp>
#include <cstdlib>
#include <ctime>
#include <vector>
#include "flocking-wander.hpp"

// Window and boid settings
const int windowWidth = 800;
const int windowHeight = 600;
const int numBoids = 150;

// Flocking parameters tuned for grouping together.
const float neighborRadius    = 60.f;
const float separationRadius  = 40.f;
const float separationWeight  = 150.0f;
const float alignmentWeight   = 1.0f;
const float cohesionWeight    = 0.5f;
const float maxAccel          = 250.f;  // maximum acceleration (and steering force)

// Wander fallback parameters (same maxAccel and maxSpeed)
const float wanderMaxAccel    = 5.f;
const float wanderMaxSpeed    = 7.f;
const float wanderOffset      = 10.f;
const float wanderRadius      = 15.f;
const float wanderRate        = 1.0f;
const float wanderTimeToTarget= 0.1f;

const float initialSpeed      = 13.f;
const float maxSpeed          = 13.f;  // maximum boid speed

int main()
{
    std::srand(static_cast<unsigned int>(std::time(nullptr)));

    // Load the boid texture (located in "src/boid-sm.png")
    sf::Texture boidTexture;
    if (!boidTexture.loadFromFile("src/boid-sm.png"))
    {
        // If texture loading fails, exit.
        return -1;
    }
    // Set the origin to the center of the texture.
    sf::Vector2u texSize = boidTexture.getSize();
    sf::Vector2f textureOrigin(texSize.x / 2.f, texSize.y / 2.f);

    // Vectors to store boid state, their behavior, and sprites for rendering.
    std::vector<Kinematic> flock;
    std::vector<FlockingBehavior> behaviors;
    std::vector<sf::Sprite> sprites;

    // Initialize each boid.
    for (int i = 0; i < numBoids; ++i)
    {
        Kinematic k;
        k.position = sf::Vector2f(static_cast<float>(std::rand() % windowWidth),
                                  static_cast<float>(std::rand() % windowHeight));
        float angle = (std::rand() % 360) * (PI / 180.f);
        k.velocity = sf::Vector2f(std::cos(angle), std::sin(angle)) * initialSpeed;
        k.orientation = angle;
        k.rotation = 0.f;
        flock.push_back(k);

        // Each boid gets its own flocking behavior instance (sharing the global flock vector).
        behaviors.push_back(FlockingBehavior(&flock,
                                               neighborRadius, separationRadius,
                                               separationWeight, alignmentWeight, cohesionWeight,
                                               maxAccel,
                                               wanderMaxAccel, wanderMaxSpeed, wanderOffset,
                                               wanderRadius, wanderRate, wanderTimeToTarget));

        // Create a sprite for the boid using the loaded texture.
        sf::Sprite sprite;
        sprite.setTexture(boidTexture);
        sprite.setOrigin(textureOrigin);
        sprites.push_back(sprite);
    }

    sf::RenderWindow window(sf::VideoMode(windowWidth, windowHeight), "Flocking & Wander Demo");
    window.setFramerateLimit(60);
    sf::Clock clock;

    while (window.isOpen())
    {
        sf::Event event;
        while (window.pollEvent(event))
        {
            if (event.type == sf::Event::Closed)
                window.close();
        }

        sf::Time dt = clock.restart();
        float deltaTime = dt.asSeconds();

        // Update each boid's kinematics.
        for (int i = 0; i < numBoids; ++i)
        {
            SteeringOutput steering = behaviors[i].getSteering(flock[i], flock[i], deltaTime);
            // Update velocity and position.
            flock[i].velocity += steering.linear * deltaTime;
            // Clamp velocity to the maximum speed.
            flock[i].velocity = clamp(flock[i].velocity, maxSpeed);
            flock[i].position += flock[i].velocity * deltaTime;

            // Wrap around window boundaries.
            if (flock[i].position.x < 0) flock[i].position.x += windowWidth;
            if (flock[i].position.y < 0) flock[i].position.y += windowHeight;
            if (flock[i].position.x > windowWidth) flock[i].position.x -= windowWidth;
            if (flock[i].position.y > windowHeight) flock[i].position.y -= windowHeight;

            // Update orientation to align with the velocity direction.
            if (vectorLength(flock[i].velocity) > 0)
                flock[i].orientation = std::atan2(flock[i].velocity.y, flock[i].velocity.x);
        }

        // Clear the window with a white background.
        window.clear(sf::Color::White);
        for (int i = 0; i < numBoids; ++i)
        {
            sprites[i].setPosition(flock[i].position);
            sprites[i].setRotation(flock[i].orientation * 180.f / PI);
            window.draw(sprites[i]);
        }
        window.display();
    }

    return 0;
}
